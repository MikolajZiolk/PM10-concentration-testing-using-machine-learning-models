---
title: "Prezentacja_CalPM"
author: "Team2"
abstract-title: "Temat"
abstract: "Zaprezentowanie przebiegu pracy i wynik贸w projektu CalPM"
format: 
  html:
    toc: true
    toc-depth: 3
    toc-location: right
    toc-title: Spis Treci
    number-sections: true
    number-depth: 3
    embed-resources: true
    html-math-method: katex
    code-tools: true
    code-block-bg: true
    code-fold: show
    code-summary: "Show and hide code"
    link-external-icon: true
    link-external-newwindow: true
    smooth-scroll: true
    self-contained: true
    citation: true
    theme: 
        dark: solar
        light: flatly
    fontsize: 1.0em
    linestretch: 1.3
    fig-align: center
execute: 
  echo: true
  error: false
  warning: false
  output: true
---

```{r}
#| echo: false
#| results: "hide"
#| label: Pakiety
pkg <- c(
  "ggthemes",
  "ggplot2",
  "tidyverse",
  "openair",
  "tune"
)

pkg |>
  purrr::map(
    .f = ~ require(.x, character.only = T) |> paste(.x)
  )
rm(pkg)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
load("plot_data.RData")

wind_set_dir <- function(kat) {
  directions <- c("N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", 
                  "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW")
  index <- floor((kat + 11.25) / 22.5) %% 16 + 1
  
  directions[index]
}

#don't modify the ops file as this is our input we should always derive from
load("ops.RData") ; ops <-
  ops |>
  na.omit() |> 
  select(-ops_pm10, -pres_sea) |> #external requirement to never use ops_pm10
  mutate(wd = wind_set_dir(wd))
  
#validation data (different measurement method)

load("data_test.RData") ; ops_validation <- 
  left_join(ops_data, bam, by = "date")|> 
  select(!grimm_pm10, -(poj_h:hour)) |> 
  relocate(bam_pm10, .before = "n_0044") |> 
  rename(grimm_pm10 = bam_pm10) |> 
  na.omit() |> 
  mutate(wd = wind_set_dir(wd))
```

# Organizacja pracy

Praca bya wykonywana w przybli偶eniu przebiegaa nastpujcego wedug diagramu blokowego:

![Diagram blokowy przedstawiajcy workflow](images/mindmap_calpm.png)

Praca rozpoczynaa si zawsze od spotkania, om贸wienia wsp贸lnie obecnego stanu projektu/celu, wyznaczeniu zada na nastpny tydzie i zapisaniu ich w Plannerze (appka teams):![Wygld tablicy pod koniec projektu](images/clipboard-1910004781.png){width="1300"}

Starano si aby ka偶dy na tydzie mia wyznaczone zadanie, kt贸re bdzie mogo by wykonywane r贸wnolegle z reszt zespou, nie zawsze byo to jednak atwe do osignicia.

Np. przy starcie projektu nale偶ao stworzy pierwszy plik, w kt贸rym zostan wczytane podstawowe biblioteki oraz dane. Gdyby ka偶dy to zrobi z osobna, zostay by zmarnowane zasoby na powtarzanie tej samej czynnoci i ci偶ko byo by dokona tego merge. Dlatego niekt贸re czynnoci, kt贸re musiay by wykonane tylko raz i wstrzymywayby reszt zespou przed prac byy przypisywane do os贸b, kt贸re wyra偶ay mo偶liwo szybkiego wykonania taska.

**Praca w jednym pliku** - celem wiczenia, aby lepiej widzie postpujcy kod pisany przez innych i stworzenie merge konflikt贸w zdecydowano si na prac w jednym pliku R. Wraz z rozwojem projektu, plik osign 1000+ linijek, co robi si ci偶kie do nawigowania po nim.

**Praca z gitem -** po wyznaczeniu task贸w, ka偶dy m贸g stworzy od main'a sw贸j branch, na kt贸rym m贸g bez przeszk贸d wykonywa zadanie, po uznaniu go za speniajce kryteria, wystawia pull request, lider robi review, gdzie decydowa si na przyczenie (bd藕 tez nie, wtedy zostawia feedback ) do main'a. Merge conflicty r贸wnie偶 byy rozwizywane przez lidera. Po udanym merge lider odhacza taska w plannerze.

![](images/clipboard-503873801.png)

![](images/clipboard-1210523945.png)

# Wykonywanie projektu

Sam projekt CalPM, zosta podzielony na czci - przygotowanie skryptu, przygotowanie przepis贸w, przygotowanie i trenowanie modeli, sprawdzenie modeli na rewalidacyjnym zestawie danych i sporzdzenie metryk i wykres贸w.

Kroki wykonywane przy wykonywaniu projektu, wszystko co mogo by robione r贸wnolegle jest napisane w jednym kroku.

1.  Stworzenie skryptu z podstawowymi danymi

2.  Utworzenie przykadowego przepisu (umo偶liwia ka偶demu tworzenie model贸w)

3.  Wytrenowanie wybranych modeli, utworzenie dodatkowych przepis贸w (najbardziej pracochonny krok)

4.  Sprawdzenie wszystkich modeli na zestawie walidacyjnym, utworzenie wykres贸w metryk i tabeli por贸wnawczych modeli.

W skrypcie za pomoc komentarzy wydzielano wsp贸lne i osobne przestrzenie, dla przykadu:

```{r}
#| eval: false
# loading all libraries and files
# List of required packages !!!! please add your libraries to the vector !!!!
required_packages <- c("tidyverse", "data.table", "dplyr",
                       "ggpubr", "ranger", "modeldata", "tidymodels",
                       "rpart.plot", "readr","vip", "ggthemes", 
                       "parsnip", "GGally", "skimr", "xgboost",
                       "doParallel", "kernlab", "ggplot2")  
#

[...]

## XGBoost model ---------------------------------------------------------------

# XGBoost model specification
xgboost_model <- 
  boost_tree(
    mode = "regression",
    trees = 200,
    min_n = tune(),
    tree_depth = tune(),
    learn_rate = tune(),
    loss_reduction = tune()
  ) |> 
  [...]
```

Wszystkie wytrenowane modele (na tym samym seedzie) byy zapisywane do pliku, celem uniknicia ponownego wykonywania czasochonnych operacji. Zastosowano proste wyra偶enie IF/ELSE kt贸rym mo偶na decydowa czy chcemy wykona cay skrypt trenujc modele od nowa

```{r}
#| eval: false
# It is better to load stored data, computation takes too long
if (xgboost_load_data) {
  
  load("xgboost_data.RData")
  
} else {

# Parallel computing 
  cores = detectCores()
  cl = makeCluster(cores)
  registerDoParallel(cl)

# Hyperparameter tuning
  xgboost_tuned_basic <- 
    tune_grid(
    object = xgboost_wf_basic,
    resamples = xgboost_folds,
    grid = xgboost_grid,
    metrics = xgboost_metrics,
    control = control_grid(verbose = TRUE)
)
```

# Lessons Learned

-   Warto lepiej zgbi temat przed planowaniem pracy - jako lider na pocztku nie za bardzo rozumiaem scope caego projektu, gdyby to poprawi mo偶na by lepiej zaplanowa r贸wnoleg prac w projekcie oraz powici wicej czasu na dopracowanie modeli/zwikszenie liczebnoci.

-   Mo偶liwe ustalenie wszystkich potrzebnych wsp贸lnych konwencji - jaki seed, w jakiej formie ka偶dy powinien przedstawi wydajno swojego modelu, jak nazywa zmienne, aby unikn chaosu (team poradzi sobie z tym tematem bardzo dobrze, ale myl 偶e jako lider powinienem to poruszy).

-   Przekombinowanie plannera - w tak prostym projekcie nie potrzebne jest, aby ka偶dy oznajmia nad czym obecnie pracuje, a co ma ju偶 oddane. Jest to przecie偶 projekt wykonywany w wolnym czasie. Metodologi pracy nale偶y dobiera do potrzeb zespou.

# Wyniki projektu

Finalnie stworzono 4 modele, kt贸rych finalne, najlepsze wytrenowane wersje prezentuj nastpujce parametry wydajnoci oraz odwzorowanie predykcyji na wykresie:

```{r}
#| echo: false
final_metrics
```

Wyjanienie przepis贸w:

-   **GLM** - przepis utworzony specjalnie dla modelu liniowego (przy u偶yciu metody hellwiga)

-   **HLWG** - przepis w kt贸rym metody zostay dobrane przy u偶yciu metody hellwiga

-   **Upgraded** - przepis utworzony poprzez rczne badanie korelacji predyktor贸w i sprawdzanie wagi predyktor贸w w wytrenowanym modelu.

```{r}
#| echo: false
ggplot(all_results, aes(x = date)) +
  geom_line(aes(y = grimm_pm10, color = "Actual"), size = 1) +
  geom_line(aes(y = .pred, color = "Predicted"), size=0.5) +
  facet_wrap(~ model, scales = "free_y") +
  labs(
    title = "Comparison of Actual and Predicted Values",
    x = "Date",
    y = "PM10 Concentration",
    color = "Values"
  ) +
  theme_minimal() +
  coord_cartesian(ylim = c(0, 75)) +
  scale_color_manual(values = c("Actual" = "green", "Predicted" = "red"))
```

Co prawda najlepszy parametr R^2^ osiga model GLM, jednak o wiele lepsze parametry RMSE oraz MAE osigna model XGBoost, wyglda si te偶 byc lepiej dopasowany na do oryginalnej krzywej, por贸wnujc te dwa modele na bardziej szczeg贸owym wykresie, mo偶na zauwa偶y wicej:

```{r}
#| echo: false
left_join(
  all_results %>%
    filter(model == "GLM") %>%
    select(date, .pred, grimm_pm10) %>%
    na.omit(),
  ops_bam %>% select(date, ops_pm10),
  by = "date"
) %>%
  select(date, grimm_pm10, ops_pm10, .pred) %>%
  rename('Calibration algorithm' = .pred,
         'Correction factor' = ops_pm10) %>%
  pivot_longer('Correction factor':'Calibration algorithm') -> to_p_glm

left_join(
  all_results %>%
    filter(model == "XGBoost") %>%
    select(date, .pred, grimm_pm10) %>%
    na.omit(),
  ops_bam %>% select(date, ops_pm10),
  by = "date"
) %>%
  select(date, grimm_pm10, ops_pm10, .pred) %>%
  rename('Calibration algorithm' = .pred,
         'Correction factor' = ops_pm10) %>%
  pivot_longer('Correction factor':'Calibration algorithm') -> to_p_xboost

to_p_glm %>%
  timeVariation(pollutant = "value",
                group = "name", 
                ylab ="Concentration PM10 [ug/m3]",
                main = "GLM") -> p_tv_glm

to_p_xboost %>%
  timeVariation(pollutant = "value",
                group = "name", 
                ylab ="Concentration PM10 [ug/m3]",
                main = "XGBoost") -> p_tv_xgboost

```

Por贸wnujc obydwa wykresy widzimy, 偶e chocia偶 faktycznie GLM predyktujema wartoc bli偶sz waciwej, to XGBoost generuje prawie identyczny ksztat krzywej, tylko liniowo przesunitej. Ten pow贸d kategoryzuje XGBoost jako lepszy model.

```{r}
#| echo: false
to_p_xboost %>% 
  timeAverage(avg.time = "day", 
              type = "name") %>% 
  filter(value < 150) %>% 
  ggplot(aes(grimm_pm10, value)) +
  geom_point() +
  facet_wrap(~name) + 
  geom_abline(slope = c(1.5, 0.5, 1),
              col = rep(c("blue", "blue",
                          "red"),
                        2)) +
  theme_bw() +
  scale_x_continuous(limits = c(0,60), expand = c(0,0)) + 
  scale_y_continuous(limits = c(0,60), expand = c(0,0)) +
  coord_obs_pred() +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(
    x =  expression("Concentration PM"[10] *
                      " [" * mu * "g m" ^ -3 * "] - BAM-1020") ,
    y = expression("Concentration PM"[10] *
                     " [" * mu * "g m" ^ -3 * "] - OPS 3330")
  )
```
